import{_ as a,c as s,o as e,aS as p}from"./chunks/framework.Dbjoj8K5.js";const g=JSON.parse('{"title":"mask | Pygame中文文档","description":"","frontmatter":{},"headers":[],"relativePath":"pygame/mask.md","filePath":"pygame/mask.md","lastUpdated":1708595373000}'),k={name:"pygame/mask.md"},i=p(`<h1 id="mask-pygame中文文档" tabindex="-1">mask | Pygame中文文档 <a class="header-anchor" href="#mask-pygame中文文档" aria-label="Permalink to &quot;mask | Pygame中文文档&quot;">​</a></h1><h2 id="pygame-mask" tabindex="-1">pygame.mask <a class="header-anchor" href="#pygame-mask" aria-label="Permalink to &quot;pygame.mask&quot;">​</a></h2><blockquote><p>Pygame 中处理图形遮罩的模块。</p></blockquote><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><ul><li>pygame.mask.from_surface() —— 从指定 Surface 对象中返回一个 Mask</li><li>pygame.mask.from_threshold() —— 从给定阈值的 Surface 对象中创建一个 Mask</li></ul><h2 id="类" tabindex="-1">类 <a class="header-anchor" href="#类" aria-label="Permalink to &quot;类&quot;">​</a></h2><ul><li>pygame.mask.Mask —— 用于表示 2d 位掩码（遮罩）的 Pygame 对象</li></ul><p>用于快速实现完美的碰撞检测，Mask 可以精确到 1 个像素级别的判断。</p><p>Pygame 1.8 新增加的。</p><h2 id="函数详解" tabindex="-1">函数详解 <a class="header-anchor" href="#函数详解" aria-label="Permalink to &quot;函数详解&quot;">​</a></h2><p><code>pygame.mask.from_surface()</code></p><p>从指定 Surface 对象中返回一个 Mask。</p><p>from_surface(Surface, threshold = 127) -&gt; Mask</p><p>Surface 对象中透明的部分设置为 1，不透明部分设置为 0。</p><p>检查每个像素的 alpha 值是否大于 threshold 参数指定的值。（alpha 通道使用 0 ~ 255 描述像素的透明度）</p><p>如果 Surface 对象是基于 colorkeys 实现的透明（而不是基于 pixel alphas），则忽略 threshold 参数。</p><p>注：关于 Surface 对象的透明实现，可参考：Surface | Pygame中文文档</p><p><code>pygame.mask.from_threshold()</code></p><p>从给定阈值的 Surface 对象中创建一个 Mask。</p><p>from_threshold(Surface, color, threshold = (0,0,0,255), othersurface = None, palette_colors = 1) -&gt; Mask</p><p>从 Surface 对象中获取 Mask，这个方法更有特色。如果只提供一个 Surface 对象，那么 Surface 对象中所有与 threshold 参数提供颜色匹配的像素均被选入 Mask 中。如果指定了 othersurface 可选参数，那么被选入 Mask 中的像素不仅需要与 threshold 参数提供颜色匹配，还需要包含在 othersurface 指定的 Surface 对象中。</p><h3 id="class-pygame-mask-mask" tabindex="-1">class pygame.mask.Mask <a class="header-anchor" href="#class-pygame-mask-mask" aria-label="Permalink to &quot;class pygame.mask.Mask&quot;">​</a></h3><p>用于表示 2d 位掩码（遮罩）的 Pygame 对象。</p><p>Mask((width, height)) -&gt; Mask</p><h4 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h4><ul><li>pygame.mask.Mask.get_size() —— 返回 Mask 的大小</li><li>pygame.mask.Mask.get_at() —— 如果像素 (x, y) 被设置，返回值是非 0</li><li>pygame.mask.Mask.set_at() —— 设置 Mask 中给定位置的值</li><li>pygame.mask.Mask.overlap() —— 返回两个 Mask 在指定偏移处的重叠坐标（如果没有返回 None）</li><li>pygame.mask.Mask.overlap_area() —— 返回两个 Mask 重叠的像素数量</li><li>pygame.mask.Mask.overlap_mask() —— 将两个 Mask 重叠的部分创建一个新的 Mask</li><li>pygame.mask.Mask.fill() —— 将所有的位设置为 1</li><li>pygame.mask.Mask.clear() —— 将所有的位设置为 0</li><li>pygame.mask.Mask.invert() —— 翻转 Mask 中所有的位（0 变 1，1 变 0）</li><li>pygame.mask.Mask.scale() —— 缩放 Mask 的尺寸</li><li>pygame.mask.Mask.draw() —— 将 Mask 绘制到另一个 Mask 上边</li><li>pygame.mask.Mask.erase() —— 用另一个 Mask 擦除 Mask</li><li>pygame.mask.Mask.count() —— 返回 Mask 被设置（为 1）的像素的数量</li><li>pygame.mask.Mask.centroid() —— 返回 Mask 的重心点</li><li>pygame.mask.Mask.angle() —— 返回像素的方向</li><li>pygame.mask.Mask.outline() —— 用列表的形式返回组成对象轮廓的点</li><li>pygame.mask.Mask.convolve() —— 返回其它 Mask 的卷积</li><li>pygame.mask.Mask.connected_component() —— 返回与某像素区域的连接的 Mask</li><li>pygame.mask.Mask.connected_components() —— 返回一组连接某像素区域的 Mask 的列表</li><li>pygame.mask.Mask.get_bounding_rects() —— 返回一组像素边界矩形的列表</li></ul><h4 id="方法详解" tabindex="-1">方法详解 <a class="header-anchor" href="#方法详解" aria-label="Permalink to &quot;方法详解&quot;">​</a></h4><p><code>pygame.mask.Mask.get_size()</code></p><p>返回 Mask 的大小。</p><p>get_size() -&gt; width,height</p><p><code>pygame.mask.Mask.get_at()</code></p><p>如果像素 (x, y) 被设置，返回值是非 0。</p><p>get_at((x,y)) -&gt; int</p><p>跟 Surface 对象一样，(0, 0) 表示左上角坐标。</p><p><code>pygame.mask.Mask.set_at()</code></p><p>设置 Mask 中给定位置的值。</p><p>set_at((x,y),value) -&gt; None</p><p><code>pygame.mask.Mask.overlap()</code></p><p>返回两个 Mask 在指定偏移处的重叠坐标（如果没有返回 None）。</p><p>overlap(othermask, offset) -&gt; x,y</p><p>重叠检测的偏移原理如下（偏移可以为负数）：</p><pre><code>+----+----------..
|A   | yoffset
|  +-+----------..
+--|B
|xoffset
|  |
:  :
</code></pre><p><code>pygame.mask.Mask.overlap_area()</code></p><p>返回两个 Mask 重叠的像素数量。</p><p>overlap_area(othermask, offset) -&gt; numpixels</p><p>返回两个 Mask 重叠的像素数量，这可以用于查看在某方向上发生碰撞的部分，或者查看两个 Mask 有多少部分发生碰撞。相似的碰撞一般会通过计算重叠部分的梯度差分被发现。</p><div class="language-Python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">Python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Mask.overlap_area(othermask,(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,y)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Mask.overlap_area(othermask,(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,y))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Mask.overlap_area(othermask,(x,y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Mask.overlap_area(othermask,(x,y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>pygame.mask.Mask.overlap_mask()</code></p><p>将两个 Mask 重叠的部分创建一个新的 Mask。</p><p>overlap_mask(othermask, offset) -&gt; Mask</p><p>返回的 Mask 尺寸是原始 Mask 和 othermask 参数指定的 Mask 重叠部分。</p><p><code>pygame.mask.Mask.fill()</code></p><p>将所有的位设置为 1。</p><p>fill() -&gt; None</p><p>将 Mask 中所有的位设置为 1。</p><p><code>pygame.mask.Mask.clear()</code></p><p>将所有的位设置为 0。</p><p>clear() -&gt; None</p><p>将 Mask 中所有的位设置为 0。</p><p><code>pygame.mask.Mask.invert()</code></p><p>翻转 Mask 中所有的位（0 变 1，1 变 0）。</p><p>invert() -&gt; None</p><p>翻转 Mask 中所有的位（0 变 1，1 变 0）。</p><p><code>pygame.mask.Mask.scale()</code></p><p>缩放 Mask 的尺寸。</p><p>scale((x, y)) -&gt; Mask</p><p>Mask 根据指定尺寸缩放后返回一个新的 Mask。</p><p><code>pygame.mask.Mask.draw</code></p><p>将 Mask 绘制到另一个 Mask 上边。</p><p>draw(othermask, offset) -&gt; None</p><p>将 Mask 绘制到另一个 Mask 上边，执行的是按位 or 操作。</p><p><code>pygame.mask.Mask.erase()</code></p><p>用另一个 Mask 擦除 Mask。</p><p>erase(othermask, offset) -&gt; None</p><p>从 Mask 上擦除 othermask 指定的像素。</p><p><code>pygame.mask.Mask.count()</code></p><p>返回 Mask 被设置（为 1）的像素的数量。</p><p>count() -&gt; pixels</p><p>返回 Mask 被设置（为 1）的像素的数量。</p><p><code>pygame.mask.Mask.centroid()</code></p><p>返回 Mask 的重心点。</p><p>centroid() -&gt; (x, y)</p><p>找到 Mask 的重心点。如果 Mask 是空的，那么返回值是 (0, 0)。</p><p><code>pygame.mask.Mask.angle()</code></p><p>返回像素的方向。</p><p>angle() -&gt; theta</p><p>找到图像中像素的大致方向（-90 度 ~ 90 度），这对于实现像素对接很有用。如果 Mask 是空的，那么返回值是 0.0。</p><p><code>pygame.mask.Mask.outline()</code></p><p>用列表的形式返回组成对象轮廓的点。</p><p>outline(every = 1) -&gt; [(x,y), (x,y) ...]</p><p>返回值是一个由点组成的列表，用于描绘穿过 Mask 的第一个对象的轮廓线。</p><p>every 可选参数用于设置点的跨度，默认是每 1 个像素。</p><p><code>pygame.mask.Mask.convolve()</code></p><p>返回其它 Mask 的卷积。</p><p>convolve(othermask, outputmask=None, offset=(0,0)) -&gt; Mask</p><p>返回一个由位组 (i-offset[0], j-offset[1]) 组成的 Mask，如果转换的 othermask 参数在右下角 (i, j) 处，那么会与自身重叠。</p><p>如果 outputmask 参数被指定，那么就会在 outputmask 参数上进行绘制，outputmask 参数会被返回。否则这个 Mask 的大小是 self.get_size() + othermask.get_size() - (1, 1)。</p><p><code>pygame.mask.Mask.connected_component()</code></p><p>返回与某像素区域的连接的 Mask。</p><p>connected_component((x,y) = None) -&gt; Mask</p><p>它会使用 SAUF 算法进行连接需要连接的 Mask。它会连通 8 个点。默认情况下，它会返回在连接图像中最大的 Mask。可选项: 一对指定的坐标，与其相连的组件会被返回。如果像素位置没有被设置，那么返回的这个 Mask 就是空的。这个 Mask 的大小会与原始 Mask 一样。</p><p><code>pygame.mask.Mask.connected_components()</code></p><p>返回一组连接某像素区域的 Mask 的列表。</p><p>connected_components(min = 0) -&gt; [Masks]</p><p>返回一组连接某像素区的 Mask 的列表。min 可选参数用于对每个连接区的指定部分过滤噪点。</p><p><code>pygame.mask.Mask.get_bounding_rects()</code></p><p>返回一组像素边界矩形的列表。</p><p>get_bounding_rects() -&gt; Rects</p><p>它会获取连接着像素块的边界矩形。每个边界矩形都是一个连接每个像素的内矩形。</p>`,109),t=[i];function o(l,r,m,n,h,c){return e(),s("div",null,t)}const M=a(k,[["render",o]]);export{g as __pageData,M as default};
