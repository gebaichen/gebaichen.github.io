import{_ as s,o as n,c as a,Q as e}from"./chunks/framework.b6PMUn9J.js";const h=JSON.parse('{"title":"Flask项目部署","description":"Flask项目部署的方式方法","frontmatter":{"date":"2023.8.20","title":"Flask项目部署","tags":["flask","web","python"],"description":"Flask项目部署的方式方法","link":"/flask/flask-bushu.html"},"headers":[],"relativePath":"flask/flask-bushu.md","filePath":"flask/flask-bushu.md","lastUpdated":1700227085000}'),p={name:"flask/flask-bushu.md"},l=e(`<h1 id="flask项目部署" tabindex="-1">Flask项目部署 <a class="header-anchor" href="#flask项目部署" aria-label="Permalink to &quot;Flask项目部署&quot;">​</a></h1><p>生产部署我建议用Gunicorn</p><h2 id="使用-gunicorn-运行程序" tabindex="-1">使用 Gunicorn 运行程序 <a class="header-anchor" href="#使用-gunicorn-运行程序" aria-label="Permalink to &quot;使用 Gunicorn 运行程序&quot;">​</a></h2><p>在开发时，我们使用 flask run 命令启动的开发服务器是由Werkzeug提供的。细分的话，Werkzeug提供的这个开发服务器应该被称为WSGI服务器，而不是单纯意义上的Web服务器。在生产环境中，我们需要一个更强健、性能更高的WSGI服务器。这些WSGI服务器也被称为独立WSGI容器（Standalone WSGI Container），因为它们可以承载我们编写的WSGI程序，然后处理HTTP请求和响应。这通常有很多选择，比如<a href="http://gunicorn.org/" target="_blank" rel="noreferrer">Gunicorn</a>、<a href="http://uwsgi-docs.readthedocs.io/en/latest/" target="_blank" rel="noreferrer">uWSGI</a>、<a href="http://www.gevent.org/" target="_blank" rel="noreferrer">Gevent</a> 等。</p><p>通常我们会根据程序的特点来选，主流的选择是使用Gunicorn和uWSGI。在这里我们将使用Gunicorn（意为Green Unicorn），它使用起来相对简单，容易配置，而且性能优秀。我们先在远程主机中使用Pip安装它：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ pip install gunicorn</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ pip install gunicorn</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>为了方便进行测试，我们可以临时设置防火墙以允许对8000端口的访问：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ sudo ufw allow 8000</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ sudo ufw allow 8000</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Gunicorn使用下面的命令模式来运行一个WGSI程序：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ gunicorn [OPTIONS] 模块名: 变量名</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ gunicorn [OPTIONS] 模块名: 变量名</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里的变量名即要运行的 WSGI 可调用对象，也就是我们使用Flask创建的程序实例，而模块名即包含程序实例的模块。在准备环节，我们已经在项目根目录下创建了一个包含生产环境下的程序实例的wsgi.py模块</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># filename:wsgi.py</span></span>
<span class="line"><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> flask </span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> Flask</span></span>
<span class="line"><span style="color:#E1E4E8;">app </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Flask(</span><span style="color:#79B8FF;">__name__</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">@app.route</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">def</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">hello_world</span><span style="color:#E1E4E8;">():</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Hello, World!&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># filename:wsgi.py</span></span>
<span class="line"><span style="color:#D73A49;">from</span><span style="color:#24292E;"> flask </span><span style="color:#D73A49;">import</span><span style="color:#24292E;"> Flask</span></span>
<span class="line"><span style="color:#24292E;">app </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Flask(</span><span style="color:#005CC5;">__name__</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1;">@app.route</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;/&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">def</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hello_world</span><span style="color:#24292E;">():</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Hello, World!&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用下面的命令即可运行程序：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ gunicorn --workers=4 wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ gunicorn --workers=4 wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在上面的命令中，我们使用--workers选项来定义worker（即工作线程）的数量。这里的数量并不是越多越好，事实上，Gunicorn只需要4～12个worker进程就可以每秒处理成百上千个请求。通常来说，worker的数量建议为（2×CPU核心数）+1。</p><p><span style="color:red;font-size:24px;">提示</span></p><p>默认的 worker 类型为同步 worker，作为替代，你也可以使用异步 worker。要使用异步 worker，你首先要安装其他异步处理库，然后在命令中通过-k选项设置对应的 worker 类，比如 gunicorn-k gevent。通常情况下，有两种情况需要使用异步worker：</p><p>第一，单独使用Gunicorn运行程序时，你的程序需要处理大量并发请求。</p><p>第二，当使用Web服务器作为代理运行在Gunicorn前面时，这时的并发数量并不是关键，使用同步worker即可，除非你有大量的耗时计算需要处理。</p><p>Gunicorn默认监听本地机的8000端口，这里的本地机指的是远程主机。为了能够在外部访问，我们可以使用--bind选项来设置程序运行的主机地址和端口，比如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ gunicorn --workers=4 --bind=0.0.0.0:8000 wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ gunicorn --workers=4 --bind=0.0.0.0:8000 wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面的命令等同于：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">$ gunicorn -w 4 -b 0.0.0.0:8000 app:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">$ gunicorn -w 4 -b 0.0.0.0:8000 app:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>如果默认的质量不能使用</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">venv/bin/gunicorn --workers=4 --bind=0.0.0.0:8000 wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">venv/bin/gunicorn --workers=4 --bind=0.0.0.0:8000 wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="gunicorn使用详解" tabindex="-1">Gunicorn使用详解 <a class="header-anchor" href="#gunicorn使用详解" aria-label="Permalink to &quot;Gunicorn使用详解&quot;">​</a></h3><p>使用gunicorn监听请求，运行以下命令</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn -w 2 -b 0.0.0.0:8000 wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn -w 2 -b 0.0.0.0:8000 wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>-w: 指定fork的worker进程数 -b: 指定绑定的端口 test: 模块名, python文件名 application: 变量名，python文件中可调用的wsgi接口名称（app对象）</p><h4 id="gunicorn相关参数" tabindex="-1">gunicorn相关参数 <a class="header-anchor" href="#gunicorn相关参数" aria-label="Permalink to &quot;gunicorn相关参数&quot;">​</a></h4><p>指定一个配置文件（py文件）</p><p>-c CONFIG,--config=CONFIG</p><p>与指定socket进行绑定</p><p>-b BIND,--bind=BIND</p><p>后台进程方式运行gunicorn进程</p><p>-D,--daemon</p><p>工作进程的数量</p><p>-w WORKERS,--workers=WORKERS</p><p>工作进程类型，包括sync（默认）,eventlet,gevent,tornado,gthread,gaiohttp</p><p>-k WORKERCLASS,--worker-class=WORKERCLASS</p><p>最大挂起的连接数</p><p>--backlog INT</p><p>日志输出等级</p><p>--log-level LEVEL</p><p>访问日志输出文件</p><p>--access-logfile FILE</p><p>错误日志输出文件</p><p>--error-logfile FILE</p><h3 id="gunicorn配置" tabindex="-1">Gunicorn配置 <a class="header-anchor" href="#gunicorn配置" aria-label="Permalink to &quot;Gunicorn配置&quot;">​</a></h3><p>Gunicorn从三个不同的地方读取配置信息。</p><p>第一个: 从framework定义的配置信息中读取,目前只对 Paster 框架有效。</p><p>第二个: 在命令行中定义,命令行中定义的配置信息将会覆盖掉框架中定义的相同的参数名的值。</p><p>第三个: 将所有的参数信息,放到一个文件中,只要是在命令行中可以定义的参数中,在配置文件中都可以定义。( 是一个Python源文件,所以你就像在写Python代码一样)</p><p>第一个地方不不介绍了,不实用。重点介绍第二种和第三种,其实这两种方式都是相同的。</p><h4 id="gunicorn-参数配置文件" tabindex="-1">gunicorn 参数配置文件 <a class="header-anchor" href="#gunicorn-参数配置文件" aria-label="Permalink to &quot;gunicorn 参数配置文件&quot;">​</a></h4><p>-c CONFIG,--config=CONFIG 指定一个配置文件（py文件） gunicorn可以写在配置文件中，下面举列说明配置文件的写法,gunicorn.conf.py</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">bind = &quot;0.0.0.0:8000&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">workers = 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">bind = &quot;0.0.0.0:8000&quot;</span></span>
<span class="line"><span style="color:#24292e;">workers = 2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>运行以下命令:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn -c gunicorn.conf.py wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn -c gunicorn.conf.py wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>运行结果和使用命令行参数，结果一样。</p><p>gunicorn 配置文件是一个 python 文件，因此可以实现更复杂的逻辑，如下：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;"># filename: gunicorn.conf.py</span></span>
<span class="line"><span style="color:#e1e4e8;">import os</span></span>
<span class="line"><span style="color:#e1e4e8;">import multiprocessing</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">bind = &#39;127.0.0.1:8000&#39;  # 绑定ip和端口号</span></span>
<span class="line"><span style="color:#e1e4e8;">backlog = 512  # 监听队列</span></span>
<span class="line"><span style="color:#e1e4e8;">chdir = os.path.dirname(os.path.abspath(__file__))  # gunicorn要切换到的目的工作目录</span></span>
<span class="line"><span style="color:#e1e4e8;">timeout = 30  # 超时</span></span>
<span class="line"><span style="color:#e1e4e8;">worker_class = &#39;sync&#39;  # 使用gevent模式，还可以使用sync 模式，默认的是sync模式</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">workers = multiprocessing.cpu_count() * 2 + 1  # 进程数</span></span>
<span class="line"><span style="color:#e1e4e8;">threads = 2  # 指定每个进程开启的线程数</span></span>
<span class="line"><span style="color:#e1e4e8;">loglevel = &#39;info&#39;  # 日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置</span></span>
<span class="line"><span style="color:#e1e4e8;">access_log_format = &#39;%(t)s %(p)s %(h)s &quot;%(r)s&quot; %(s)s %(L)s %(b)s %(f)s&quot; &quot;%(a)s&quot;&#39;  # 设置gunicorn访问日志格式，错误日志无法设置</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">其每个选项的含义如下：</span></span>
<span class="line"><span style="color:#e1e4e8;">h          remote address</span></span>
<span class="line"><span style="color:#e1e4e8;">l          &#39;-&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">u          currently &#39;-&#39;, may be user name in future releases</span></span>
<span class="line"><span style="color:#e1e4e8;">t          date of the request</span></span>
<span class="line"><span style="color:#e1e4e8;">r          status line (e.g. \`\`GET / HTTP/1.1\`\`)</span></span>
<span class="line"><span style="color:#e1e4e8;">s          status</span></span>
<span class="line"><span style="color:#e1e4e8;">b          response length or &#39;-&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">f          referer</span></span>
<span class="line"><span style="color:#e1e4e8;">a          user agent</span></span>
<span class="line"><span style="color:#e1e4e8;">T          request time in seconds</span></span>
<span class="line"><span style="color:#e1e4e8;">D          request time in microseconds</span></span>
<span class="line"><span style="color:#e1e4e8;">L          request time in decimal seconds</span></span>
<span class="line"><span style="color:#e1e4e8;">p          process ID</span></span>
<span class="line"><span style="color:#e1e4e8;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#e1e4e8;">accesslog = os.path.join(chdir, &quot;log/gunicorn_access.log&quot;)  # 访问日志文件</span></span>
<span class="line"><span style="color:#e1e4e8;">errorlog = os.path.join(chdir, &quot;log/gunicorn_error.log&quot;)  # 访问日志文件</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;"># filename: gunicorn.conf.py</span></span>
<span class="line"><span style="color:#24292e;">import os</span></span>
<span class="line"><span style="color:#24292e;">import multiprocessing</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">bind = &#39;127.0.0.1:8000&#39;  # 绑定ip和端口号</span></span>
<span class="line"><span style="color:#24292e;">backlog = 512  # 监听队列</span></span>
<span class="line"><span style="color:#24292e;">chdir = os.path.dirname(os.path.abspath(__file__))  # gunicorn要切换到的目的工作目录</span></span>
<span class="line"><span style="color:#24292e;">timeout = 30  # 超时</span></span>
<span class="line"><span style="color:#24292e;">worker_class = &#39;sync&#39;  # 使用gevent模式，还可以使用sync 模式，默认的是sync模式</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">workers = multiprocessing.cpu_count() * 2 + 1  # 进程数</span></span>
<span class="line"><span style="color:#24292e;">threads = 2  # 指定每个进程开启的线程数</span></span>
<span class="line"><span style="color:#24292e;">loglevel = &#39;info&#39;  # 日志级别，这个日志级别指的是错误日志的级别，而访问日志的级别无法设置</span></span>
<span class="line"><span style="color:#24292e;">access_log_format = &#39;%(t)s %(p)s %(h)s &quot;%(r)s&quot; %(s)s %(L)s %(b)s %(f)s&quot; &quot;%(a)s&quot;&#39;  # 设置gunicorn访问日志格式，错误日志无法设置</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#24292e;">其每个选项的含义如下：</span></span>
<span class="line"><span style="color:#24292e;">h          remote address</span></span>
<span class="line"><span style="color:#24292e;">l          &#39;-&#39;</span></span>
<span class="line"><span style="color:#24292e;">u          currently &#39;-&#39;, may be user name in future releases</span></span>
<span class="line"><span style="color:#24292e;">t          date of the request</span></span>
<span class="line"><span style="color:#24292e;">r          status line (e.g. \`\`GET / HTTP/1.1\`\`)</span></span>
<span class="line"><span style="color:#24292e;">s          status</span></span>
<span class="line"><span style="color:#24292e;">b          response length or &#39;-&#39;</span></span>
<span class="line"><span style="color:#24292e;">f          referer</span></span>
<span class="line"><span style="color:#24292e;">a          user agent</span></span>
<span class="line"><span style="color:#24292e;">T          request time in seconds</span></span>
<span class="line"><span style="color:#24292e;">D          request time in microseconds</span></span>
<span class="line"><span style="color:#24292e;">L          request time in decimal seconds</span></span>
<span class="line"><span style="color:#24292e;">p          process ID</span></span>
<span class="line"><span style="color:#24292e;">&quot;&quot;&quot;</span></span>
<span class="line"><span style="color:#24292e;">accesslog = os.path.join(chdir, &quot;log/gunicorn_access.log&quot;)  # 访问日志文件</span></span>
<span class="line"><span style="color:#24292e;">errorlog = os.path.join(chdir, &quot;log/gunicorn_error.log&quot;)  # 访问日志文件</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>使用配置文件启动Gunicorn</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn --config=gunicorn.conf.py wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn --config=gunicorn.conf.py wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>和上面用命令行配置的效果完全一样，当然两者还可以结合起来用:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn --config=gunicorn.conf.py --worker-class=eventlet wsgi:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn --config=gunicorn.conf.py --worker-class=eventlet wsgi:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>worker-class默认是sync(同步),我们也可以配置成了 eventlet(并发的)</p><h4 id="第二种并发方式-多线程" tabindex="-1">第二种并发方式（多线程） <a class="header-anchor" href="#第二种并发方式-多线程" aria-label="Permalink to &quot;第二种并发方式（多线程）&quot;">​</a></h4><p>Gunicorn 还允许每个 worker 拥有多个线程。在这种场景下，Python 应用程序每个 worker 都会加载一次，同一个 worker 生成的每个线程共享相同的内存空间。</p><p>为了在 Gunicorn 中使用多线程。我们使用了 <code>threads</code> 模式。每一次我们使用 <code>threads</code> 模式，worker 的类就会是 <code>gthread</code>：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn --workers=5 --threads=2 main:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn --workers=5 --threads=2 main:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上一条命令等同于：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn --workers=5 --threads=2 --worker-class=gthread main:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn --workers=5 --threads=2 --worker-class=gthread main:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在我们的例子里面最大的并发请求数就是 <code>worker * 线程</code>，也就是10。</p><p>在使用 worker 和多线程模式时建议的最大并发数量仍然是 <span style="color:red;">(2*CPU)+1</span> 。</p><p>因此如果我们使用四核（4 个 CPU）机器并且我们想使用 workers 和多线程模式，我们可以使用 3 个 worker 和 3 个线程来得到最大为 9 的并发请求数量。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">gunicorn --workers=3 --threads=3 main:app</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">gunicorn --workers=3 --threads=3 main:app</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,77),o=[l];function r(c,i,t,d,u,b){return n(),a("div",null,o)}const y=s(p,[["render",r]]);export{h as __pageData,y as default};
